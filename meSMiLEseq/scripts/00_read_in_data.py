#!/usr/bin/env python
# coding: utf-8

import argparse

import os
import sys


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


from collections import Counter



print('#########################################################################')
print('#### Data Wrangling with SmileSeq sequences Â©Antoni Gralak_13.08.2024####')
print('#########################################################################')

#Define paths
this_path = os.getcwd()
sys.path.append(this_path)
import functions

data_path = '../exemplary_data/'

save_path = '../output/00_read_in_data/'

try:
    os.mkdir(save_path)
except FileExistsError:
    pass

# load metadata file
metadata = pd.read_csv(data_path + '/metadata.csv', sep=';')


# Creating a parser argument
parser = argparse.ArgumentParser("""This script reads in Smile Seq data from fastq files generated by illumina,
demultiplexes the reads and saves everything as csvs.""")

parser.add_argument('-sms', '--sms_name', type=str, help='Smile-seq experiment number. E.g. exp1.', required=True)

parser.add_argument('-tf', '--Transcription_factor', type=str, nargs='+', help="""TFs to be included. By default all TFs
 that were approved in the experiment. Parse multiple or single TFs.""")

# Parse the command line arguments
args = parser.parse_args()
arguments = vars(args)

experiment_name = arguments['sms_name']

if experiment_name in ['exp1', 'exp2', 'exp3']:
    input_id = 'input1' 
    methylated_BC = "AGTA"
    unmethylated_BC = "GAGT"
elif experiment_name in ['exp4', 'exp5', 'exp6', 'exp7', 'exp8']:
    input_id = 'input2'
    methylated_BC = "AGTA"
    unmethylated_BC = "GAAT"
elif experiment_name in ['exp9', 'exp10', 'exp11', 'exp12', 'exp13', 'exp14']:
    input_id = 'input3'
    methylated_BC = "AGTA"
    unmethylated_BC = "GAAT"
elif experiment_name in ['exp15', 'exp16', 'exp17', 'exp18', 'exp19', 'exp20', 'exp21', 'exp22', 'exp23']:
    input_id = 'input4'
    methylated_BC = "AGTA"
    unmethylated_BC = "GAAT"
else:
    print("-sms needs to be a experiment ID, e.g. exp1 (possible options 1 to 23). Stopping script.")
    sys.exit(1)



if arguments['Transcription_factor']:
    to_be_analyzed = arguments['Transcription_factor']
    
else:
    to_be_analyzed = list(metadata[(metadata['experiment'] == experiment_name) & (metadata['approved'] == True)]['TF'])



# ### Read in everything
print('Loading files...')

all_files = os.listdir(data_path)

eluted_seqs = functions.filter_my_files_for_fastq(all_files, experiment_name)


input_seqs = functions.filter_my_files_for_fastq(all_files, input_id)


# first process eluted
print('Reading eluted sequences...')
eluted_seqs = [functions.readin_fastq(data_path,eluted_seqs[x]) for x in range(len(eluted_seqs))] 


# Important to check read config! In this one we had a 45/45 split, my library is 75 bp i.e 15 overlap. 
# R1 covers methl BC, BC and parts of 24 N, Read 2 covers 24 N + 1. Therefore reverse transcribe R2, 
# crop R1 to 30 bp and concatenate the two together.
# 
# And since it can happend that python mixes the order in the list (i.e. R1 should be first and R2 second, 
# but it happend to me that R2 was first and R1 second), there is a loop to check what is what. 
# R1 starts with 'GGGG' while R2 with 'GGTC'.


if eluted_seqs[0].iloc[0,0][0:4] == 'GGTC':
    rt_eluted_seqs = [functions.rev_complement(eluted_seqs[0].iloc[k,0]) for k in range(len(eluted_seqs[0]))]
    eluted_seqs = eluted_seqs[1]
else:
    rt_eluted_seqs = [functions.rev_complement(eluted_seqs[1].iloc[k,0]) for k in range(len(eluted_seqs[0]))]
    eluted_seqs = eluted_seqs[0]
    
rt_eluted_seqs = pd.DataFrame(rt_eluted_seqs)
    


eluted_seqs = pd.DataFrame([eluted_seqs.iloc[k,0][0:30] for k in range(len(eluted_seqs))])


# Rownames of this df are not 0,1,2,3... but 0, 5, etc (artefact from fastq file). And if the indices do not match, 
# you can't combine. Thus:


eluted_seqs = pd.DataFrame(eluted_seqs.values.tolist())
rt_eluted_seqs = pd.DataFrame(rt_eluted_seqs.values.tolist())


eluted_seqs = eluted_seqs + rt_eluted_seqs



# filter reads with N

fltr= ['N' not in eluted_seqs.iloc[i,0] for i in range(0,len(eluted_seqs))]
eluted_seqs = eluted_seqs[fltr]


# ### Analysis of libraries
# 
print('Files loaded.')
print('############################')
print('Starting demultiplexing eluted...')
# First input, then eluted. Extract from sequences meth_BC, BC, lfl (left flank), rfl (right flank) and random24.
# Then, I save all extracted sequences as a DataFrame upon which I demultiplex my pool by BC and make sure that rfl and BC+lfl are correct. 
# Create stacked barplot for all BCs which had a corresponding GFP signal in Mitomi button and show modification status (methylated/nonmethylated).

# # eluted



meth_BC = [eluted_seqs.iloc[x,0][18:22] for x in range(len(eluted_seqs))]
BC = [eluted_seqs.iloc[x,0][22:29] for x in range(len(eluted_seqs))]
lfl = [eluted_seqs.iloc[x,0][29:31] for x in range(len(eluted_seqs))]
rdm24 = [eluted_seqs.iloc[x,0][31:55] for x in range(len(eluted_seqs))]
rfl = [eluted_seqs.iloc[x,0][55:60] for x in range(len(eluted_seqs))]



sdf = pd.DataFrame.from_dict({'methl':meth_BC, 'BC':BC, 'lfl':lfl, 'random24':rdm24,'rfl':rfl})

# Some experiments had a contamination with a sequence from the BstBI control library, thus the filtering steps.

# filtering the control library: it has a prominent TTCGAA or AAGCTT
fltr1 = sdf['random24'].str.contains(r'(TTCGAA)')

# next, the control starts with ACGTA or TGCAT and ends with CGTTA or GCAAT (different than random libraries)

fltr2 = sdf['random24'].str.contains(r'^(ACGTA)') 
fltr3 = sdf['random24'].str.contains(r'(CGTTA)$')


# lastly, some conservative filters reminiscent of the BstBI control
fltr4 = sdf['random24'].str.contains(r'(CGTTT)')
fltr5 = sdf['random24'].str.contains(r'(TTTCG)')
fltr6 = sdf['random24'].str.contains(r'(AAACG)')
fltr7 = sdf['random24'].str.contains(r'(CGAAA)')

fltr = fltr1 | fltr2
fltr = fltr | fltr3
fltr = fltr | fltr4
fltr = fltr | fltr5
fltr = fltr | fltr6
fltr = fltr | fltr7

sdf = sdf[~fltr]

# Extract sequences and save them in a list
print('Saving eluted sequences.')

for TF in to_be_analyzed: 
    BC_df = sdf[sdf['BC'] == metadata[(metadata['experiment'] == experiment_name) & (metadata['TF'] == TF)]['Barcode'].values[0]]
    #match flanks
    BC_df = BC_df[(BC_df['rfl'] == 'TAGAG') & (BC_df['lfl'] == 'TA')]

    BC_df.to_csv(save_path + f'{experiment_name}_{TF}_raw_data.csv', index=False)



######################################################################################################
# Now, exactly the same for the input sequences
print('Reading input sequences...')
input_seqs = [functions.readin_fastq(data_path,input_seqs[x]) for x in range(len(input_seqs))] 

if input_seqs[0].iloc[0,0][0:4] == 'GGTC':
    rt_input_seqs = [functions.rev_complement(input_seqs[0].iloc[k,0]) for k in range(len(input_seqs[0]))]
    input_seqs = input_seqs[1]
else:
    rt_input_seqs = [functions.rev_complement(input_seqs[1].iloc[k,0]) for k in range(len(input_seqs[0]))]
    input_seqs = input_seqs[0]
    
rt_input_seqs = pd.DataFrame(rt_input_seqs)

input_seqs = pd.DataFrame([input_seqs.iloc[k,0][0:30] for k in range(len(input_seqs))])

input_seqs = pd.DataFrame(input_seqs.values.tolist())
rt_input_seqs = pd.DataFrame(rt_input_seqs.values.tolist())

input_seqs = input_seqs + rt_input_seqs

fltr= ['N' not in input_seqs.iloc[i,0] for i in range(0,len(input_seqs))]
input_seqs = input_seqs[fltr]


print('############################')
print('Starting demultiplexing input...')

meth_BC = [input_seqs.iloc[x,0][18:22] for x in range(len(input_seqs))]
BC = [input_seqs.iloc[x,0][22:29] for x in range(len(input_seqs))]
lfl = [input_seqs.iloc[x,0][29:31] for x in range(len(input_seqs))]
rdm24 = [input_seqs.iloc[x,0][31:55] for x in range(len(input_seqs))]
rfl = [input_seqs.iloc[x,0][55:60] for x in range(len(input_seqs))]

sdf = pd.DataFrame.from_dict({'methl':meth_BC, 'BC':BC, 'lfl':lfl, 'random24':rdm24,'rfl':rfl})


# as described above, I need to filter out the control library
# filtering the control library: it has a prominent TTCGAA or AAGCTT 
fltr1 = sdf['random24'].str.contains(r'(TTCGAA)')


# next, the control starts with ACGTA or TGCAT and ends with CGTTA or GCAAT

fltr2 = sdf['random24'].str.contains(r'^(ACGTA)') 
fltr3 = sdf['random24'].str.contains(r'(CGTTA)$')


fltr4 = sdf['random24'].str.contains(r'(CGTTT)')
fltr5 = sdf['random24'].str.contains(r'(TTTCG)')
fltr6 = sdf['random24'].str.contains(r'(AAACG)')
fltr7 = sdf['random24'].str.contains(r'(CGAAA)')

fltr = fltr1 | fltr2
fltr = fltr | fltr3
fltr = fltr | fltr4
fltr = fltr | fltr5
fltr = fltr | fltr6
fltr = fltr | fltr7

sdf = sdf[~fltr]

print('Saving input sequences.')
for TF in to_be_analyzed: 
    BC_df = sdf[sdf['BC'] == metadata[(metadata['experiment'] == experiment_name) & (metadata['TF'] == TF)]['Barcode'].values[0]]
    #match flanks
    BC_df = BC_df[(BC_df['rfl'] == 'TAGAG') & (BC_df['lfl'] == 'TA')]
    position = metadata[(metadata['experiment'] == experiment_name) & (metadata['TF'] == TF)]['Chip_pos'].values[0]
    BC_df.to_csv(save_path + f'{input_id}_{position}_raw_data.csv', index=False)


print('Finished 00_read_in_data!')



